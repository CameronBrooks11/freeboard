/**
 * @module models/User
 * @description Mongoose schema and model for user authentication and management in the Freeboard application.
 *  - Uses `nanoid` for unique user IDs
 *  - Hashes passwords automatically before save
 *  - Tracks registration and last login timestamps
 */

import mongoose from "mongoose";
import bcrypt from "bcryptjs";
import { ObjectId } from "mongodb";
import { nanoid } from "nanoid";
import {
  EMAIL_POLICY_MESSAGE,
  PASSWORD_POLICY_MESSAGE,
  isStrongPassword,
  isValidEmail,
} from "../validators.js";

/**
 * @typedef {Object} MongooseSchema
 *   Alias for mongoose.Schema
 * @typedef {Object} MongooseModel
 *   Alias for mongoose.Model
 */

const Schema = mongoose.Schema;

/**
 * Ensure ObjectId valueOf returns string representation.
 */
ObjectId.prototype.valueOf = function () {
  return this.toString();
};

/**
 * User document schema.
 *
 * @typedef {Object} UserDoc
 * @property {string} _id             - Unique ID generated by nanoid.
 * @property {string} email           - User email address (lowercased, trimmed).
 * @property {string} password        - Hashed user password.
 * @property {boolean} admin          - Whether the user has admin privileges.
 * @property {boolean} active         - Whether the user account is active.
 * @property {Date} registrationDate  - Date when the user registered.
 * @property {Date} lastLogin         - Timestamp of last login.
 * @property {Date} createdAt         - Auto-generated document creation timestamp.
 * @property {Date} updatedAt         - Auto-generated document update timestamp.
 */

/**
 * Mongoose schema for the User model.
 *
 * @type {MongooseSchema}
 */
const UserSchema = new Schema(
  {
    _id: {
      type: String,
      default: () => nanoid(), // Generate unique ID using nanoid
    },
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,      // Remove surrounding whitespace
      lowercase: true, // Store emails in lowercase
      validate: {
        validator: isValidEmail,
        message: EMAIL_POLICY_MESSAGE,
      },
    },
    password: {
      type: String,
      required: true,  // Plaintext will be hashed before save
      validate: {
        validator(value) {
          const isPasswordModified =
            typeof this?.isModified === "function"
              ? this.isModified("password")
              : true;
          if (!isPasswordModified) {
            return true;
          }
          return isStrongPassword(value);
        },
        message: PASSWORD_POLICY_MESSAGE,
      },
    },
    admin: {
      type: Boolean,
      required: true,
      default: false,  // Standard users are not admins by default
    },
    active: {
      type: Boolean,
      required: true,
      default: true,   // Accounts are active by default
    },
    registrationDate: {
      type: Date,
      required: true,
      default: Date.now, // Default to current time
    },
    lastLogin: {
      type: Date,
      required: true,
      default: Date.now, // Updated on each login
    },
  },
  {
    timestamps: true, // Adds createdAt and updatedAt fields
  },
);

const ensureNoDirectPasswordUpdate = function (next) {
  const update = this.getUpdate() || {};
  const directPasswordUpdate =
    update.password !== undefined || update.$set?.password !== undefined;

  if (directPasswordUpdate) {
    return next(
      new Error(
        "Direct password updates are not supported through update queries. Use a dedicated password reset/change flow."
      )
    );
  }

  return next();
};

UserSchema.pre("findOneAndUpdate", ensureNoDirectPasswordUpdate);
UserSchema.pre("updateOne", ensureNoDirectPasswordUpdate);
UserSchema.pre("updateMany", ensureNoDirectPasswordUpdate);

/**
 * Pre-save hook to hash the password if it has been modified.
 */
UserSchema.pre("save", function (next) {
  if (!this.isModified("password")) {
    return next();
  }
  bcrypt.genSalt((err, salt) => {
    if (err) {
      return next(err);
    }
    bcrypt.hash(this.password, salt, (err, hash) => {
      if (err) {
        return next(err);
      }
      this.password = hash;
      next();
    });
  });
});

/**
 * Mongoose model for users.
 *
 * @type {MongooseModel}
 */
export default mongoose.model("User", UserSchema);
